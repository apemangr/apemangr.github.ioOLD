<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Análisis y procesamiento de señales on Apemangr&#39;s Braindump</title>
    <link>https://apemangr.github.io/tags/an%C3%A1lisis-y-procesamiento-de-se%C3%B1ales/</link>
    <description>Recent content in Análisis y procesamiento de señales on Apemangr&#39;s Braindump</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <copyright>apemangr</copyright>
    <lastBuildDate>Wed, 10 Nov 2021 00:00:00 -0300</lastBuildDate><atom:link href="https://apemangr.github.io/tags/an%C3%A1lisis-y-procesamiento-de-se%C3%B1ales/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Análisis y procesamiento de señales - Clase 11</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_11/</link>
      <pubDate>Wed, 10 Nov 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_11/</guid>
      <description>Respuesta en frecuencia de filtros digitales Los sistemas digitales invariantes (SLI) en tiempo discreto actúan como filtros digitales.
Los filtros FIR (Finite Impulse Response) no tienen realimentación. Para el diseño de estos filtros lo que se hace es: Encontrar los coeficientes de su respuesta impulso \(h(n)\) a partir de la respuesta de frecuencia deseada.
Los filtros IIR (Infinite Impulse Response) tienen realimentación. Para el diseño lo que se hace es: Encontrar los coeficientes de su ecuación en diferencia a partir de la respuesta de frecuencia deseada.</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 10</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_10/</link>
      <pubDate>Sun, 07 Nov 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_10/</guid>
      <description>Si calculamos la DTFT de \(\delta[n]\) obtenemos
\[X(\omega) = \sum_{n=-\infty}^{\infty} \delta[n]e^{-j \omega n} = 1\]
Por lo tanto, podemos decir que la DTFT de un impulso unitario es independiente de la frecuencia y que no tiene componentes en la parte imaginaria (senos).
Ejemplo
Calcular la DTFT de
\[x[n]= \delta[n+1] + 2\delta[n] + 3 \delta[n-1] + 4 \delta[n-2] + 5\delta[n-3]\]
\[X(\omega) = \sum_{n=-\infty}^{\infty} x[n] e^{-j \omega n}\]
\[X(\omega) = e^{j\omega} + 2 + 3e^{-j\omega} + 4 e^{-j 2 \omega} + 5 e^{-j3\omega}\]</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 9</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_9/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_9/</guid>
      <description>Transformada discreta en el tiempo de Fourier (DTFT) Esta transformada nos genera apartir de una secuencia \(x[n]\) genera una representación en el dominio de la frecuencia.
\[x[n] \longrightarrow X[\omega]\]
\[X(\omega) = \sum_{n=-\infty}^{\infty}x[n]e^{-j \omega n}\]
Recordando la identidad de Euler
\[e^{-j \omega} = \cos(\omega) +j \sin(\omega)\]
Ahora si utilizamos la identidad de Euler en la DTFT queda como
\[X(\omega) = \sum_{n= -\infty}^{\infty} x[n] \cos(\omega n) - j \sum_{n= -\infty}^{\infty} x[n]\sin(\omega n)\]</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 8</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_8/</link>
      <pubDate>Fri, 05 Nov 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_8/</guid>
      <description>Convolución mediante el método &amp;ldquo;Slidding strip&amp;rdquo; Este método analítico básicamente consiste en:
   Voltear la señal más pequeña    Desplazarla en todo el intervalo de la muestra    Multiplicar las señales en sus puntos de intersección    Convolución mediante el método &amp;ldquo;Suma por columnas&amp;rdquo; Si tenemos las señales \(x[n]\) y \(h[n]\) con un soporte compacto y de largo \(L_h=M\), \(L_x=N\) se tiene que</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 7</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_7/</link>
      <pubDate>Thu, 04 Nov 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_7/</guid>
      <description>Convolución discreta Operación matemática entre \(x[n]\) (entrada) y su repuestal impulso, resultando en \(y[n]\).
Sabemos que toda señal discreta se puede representar como un tren de impulsos desplazados.
\[x[n] = \sum_{k=-\infty}^{\infty} x[k]\delta[n-k]\]
También sabemos que la respuesta de un sistema a un impulso unitario es:
\[x[n]=\delta[n]\]
\[h[n]=T&amp;lt;\delta[n]&amp;gt;\]
Si el operador T es LTI
\[h[n-k]=T&amp;lt;\delta[n-k]&amp;gt;\]
La respuesta del sistema \(y[n]\) a una entrada \(x[n]\)
\[y[n]= T&amp;lt;x[n]&amp;gt;\] \[y[n]=T \left\langle \sum_{k=-\infty}^{\infty}x[k]\delta[n-k] \right\rangle\]
Como el operador T sólo opera en n, podemos sacar la sumatoria de \(n[k]\).</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 6</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_6/</link>
      <pubDate>Thu, 28 Oct 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_6/</guid>
      <description>Operador de corrimiento Se representa como \(\lambda^{-1}\), lo que hace es representar cuanto se ha corrido una señal a la izquierda.
Ejemplo:
\[a_{p}y[n-p]+\cdots+a_{1}y[n-1]+a_{0}y[n]=0\]
Al aplicar el operador queda de la siguiente manera
\[a_{p}\lambda^{-p}y[n]+\cdots+a_{1}\lambda^{-1}y[n]+a_{0}y[v]=0\]
Ahora factorizamos el \(y[n]\)
\[[a_{p}\lambda^{-p}+\cdots+a_{1}\lambda^{-1}+a_{0}]y[n]=0\]
De la ecuación anterior se obtienen &amp;ldquo;p&amp;rdquo; soluciones \(\lambda_1, \lambda_2, \cdots, \lambda_p\) que corresponden a los valores propios de la ecuación en diferencia. Dependiendo de los valores propios que obtengamos tendremos dos casos.</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 3</title>
      <link>https://apemangr.github.io/posts/20211005122614-analisis_y_procesamiento_de_senales_clase_3/</link>
      <pubDate>Tue, 26 Oct 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/20211005122614-analisis_y_procesamiento_de_senales_clase_3/</guid>
      <description>Secuencias fundamentales A continuación se muestra como representar el escalón e impulso unitario en Matlab.
Impulso unitario function[x, n] = impulso(n0, n1, n2) % Genera x(n) = impulso(n - n0) para n1 &amp;lt;= n &amp;lt;= n2n = [n1 : n2]; % genera vector n desde n1 a n2x = [(n - n0) == 0]; % si la resta es = 0, genera un 1x = single(x); % convierte valor lógico a numéricoEscalón unitario function[x, n] = escalon(n0, n1, n2,A) % Genera x(n) = escalon(n - n0) para n1 &amp;lt;= n &amp;lt;= n2n = [n1 : n2]; % genera vector n desde n1 a n2x = [(n - n0) &amp;gt;= 0]; % si la resta es &amp;gt;= 0, genera un 1x = A*single(x); % convierte valor lógico a numéricoSecuencias aleatorias Estas secuencias se utlizan para representar ruido, y se modelan mediante variables aleatorias de &amp;ldquo;teoría de probabilidad&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 5</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_5/</link>
      <pubDate>Tue, 26 Oct 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_5/</guid>
      <description>Respuesta impulso Es la respuesta estado cero del sistema a un impulso en tiempo discreto de amplitud 1 aplicado en \(n=0\).
La respuesta impulso tiene gran importancia, ya que puede ser utilizada para predecir la respuesta estado cero del sistema a cualquier entrada mediante la operación de convolución, si conocer la transformación \(T\) que realiza el sistema.
Estabilidad Un sistema es estable si cualquier entrada acotada produce una salida acotada.</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 4</title>
      <link>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_4/</link>
      <pubDate>Mon, 25 Oct 2021 00:00:00 -0300</pubDate>
      
      <guid>https://apemangr.github.io/posts/2021-analisis_y_procesamiento_de_senales_clase_4/</guid>
      <description>Sistemas discretos Es un dispositivo o algoritmo que opera sobre una señal discreta, que es la &amp;ldquo;entrada o excitación&amp;rdquo;, de acuerdo a una regla bien definida, para producir una señal discreta en el tiempo, que es la &amp;ldquo;salida&amp;rdquo; o respuesta del sistema.
 Siempre debe existir una relación única entre la secuencia de entrada y salida la que se pruede representar como \(y(n)=T[x(n)]\), donde \(T\) es la transformación que realiza el sistema.</description>
    </item>
    
    <item>
      <title>Análisis y procesamiento de señales - Clase 2</title>
      <link>https://apemangr.github.io/posts/20210830183216-analisis_clase2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://apemangr.github.io/posts/20210830183216-analisis_clase2/</guid>
      <description>Una señal continua corresponde a una función f(x), donde f ∈ R, y está definida en el intervalo infinito 𝑡 ∈ [−∞, ∞].
 Una señal discreta corresponde a una función definida sólo en intervalos de tiempo discretos y fijos. 𝑡 = 𝑛 𝑇𝑠 ∀𝑛 ∈ ℤ 𝑇𝑠- Sampling Time
 Propiedades de las señales discretas Definición causalidad Una señal (función) discreta 𝑓[𝑛] de la forma: 𝑓 [𝑛] = … , 𝑓[−1] , 𝑓[0] , 𝑓[1] , … , 𝑓[𝑘] , … es causal si y solo si 𝑓[𝑛] = 0 para N &amp;lt; 0.</description>
    </item>
    
  </channel>
</rss>
